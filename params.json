{
  "name": "Racerdroid",
  "tagline": "A tool to detect concurrency bugs in Android applications",
  "body": "# RacerDroid\r\n\r\n### Introduction\r\nThis is a site to display the test result of RacerDroid. We perform RacerDroid on several open source applications to evaluate the feasibility of the technique. The numerical result is shown in the table.\r\n\r\nSubject | Components | # of potential data races | TP | FP | TP (manual) | FP (manual)\r\n--------|------------|---------------------------|----|----|-------------|------------\r\nToDoWidget | ColorCircle | 1 | 0 | 1 | 0 | 1\r\nConnectBot | HostEditorActivity | 5 | 2 | 3 | 2 | 3\r\nConnectBot | HostListActivity | 4 | 2 | 2 | 2 | 2\r\nConnectBot | PubkeyListActivity | 4 | 0 | 4 | 0 | 4\r\nConnectBot | TerminalManager | 2 | 2 | 0 | 2 | 0\r\nAnyMemo | DownloaderAnyMemo | 1 | 1 | 0 | 1 | 0\r\nMyTrack | MyTracks/TrackRecordingService | 1 | 1 | 0 |1 | 0\r\nOI File Manager | FileListManager | 1 | 1 | 0 | 1 | 0\r\n\r\nThe following sections describe the details of each case.\r\n**The code of the test case can be downloaded from the link at the top of the page or https://github.com/midori1/RacerDroid.**\r\n\r\n\r\n### MyTracks\r\n[MyTrack](https://play.google.com/store/apps/details?id=com.zihua.android.mytracks) is an app to record your track.\r\nThe detail of the test of this app is presented on the paper. The example in the following figure shows the segment codes that are related to this race. \r\n\r\n![a code snippet of Mytracks releated to the data race](https://static.oschina.net/uploads/img/201605/12220903_owKA.png \"a code snippet of Mytracks releated to the data race\")\r\n\r\nFig.1 a code snippet of Mytracks releated to the data race\r\n\r\nIn the activity MyTracks, when the user presses the button to start a track recording, startRecording() callback will be invoked, which starts and binds TrackRecordingService service. As soon as the service is ready, an event would be sent to the Looper of UI thread and callback onServiceConnected() will be executed when this event is dispatched, which calls startNewTrack() in TrackRecordingService through IPC mechanism. When user stops recording, stopRecording() callback will be invoked which stops and unbinds TrackRecordingService. This procedure would invoke onDestroy() asynchronously that set the “providerUtils” to null. In the ‘normal’ execution, onDestroy() will be invoked after startNewTrack(). However, there exists a situation that is contrary to the ‘normal’ execution. Due to TrackRecordingService is started and stopped asynchronously, startNewTrack() may still not be executed while onDestroy() has been performed, and an exception is thrown when startNewTrack() is invoked.\r\n\r\nAs our test case generation tool is still developing, in order to confirm this potential data race, we first generate a test case manually that will trigger these two callbacks. Fig.2 shows the corresponding test case. This test case first press menu button to show the options menu on the screen and start a recording by press the record button. Then we call the options menu again and press the button to stop the record. At last, we save the record. When this test case is executed without controlling schedule, onServiceConnected() will be invoked before onDestroy() with high probability. Therefore, no exception will be thrown. During the test case replay, when onServiceConnected() is monitored to be scheduled, RacerDroid will suspend its dispatch by removing it from the queue. After onDestroy() callback of service TrackRecordingService  is scheduled, RacerDroid will then resume the execution of onServiceConnected() task. In this way, this concurrency bug is guaranteed to be produced.\r\n\r\n![Test case of MyTrack](https://static.oschina.net/uploads/img/201605/12223734_xkcA.png \"Test case of MyTrack\")\r\n\r\nFig.2 Test case of MyTrack\r\n\r\n### AnyMemo \r\n[AnyMemo](http://anymemo.org/) is a free open-sourced spaced repetition flashcard learning software similar to SuperMemo for Android mobile phones. We use test it on version 10.2 whose code can be downloaded in https://github.com/helloworld1/AnyMemo. This data race is reported in [].\r\n\r\nThe following figure shows the segment codes that are related to this race. When `DownloaderAnyMemo`(the activity used to download the data bases) is shown to the user, `onCreate()` will invoke `initialRetrieve()` which create a background thread that downloads data. During the downloading, the user is notified about the progress using a `ProgressDialog` component. After the downloading task is finish, a message include a `Runnable` object will be posted to the message queue indicates the downloading is finish and the data will be displayed to the user. \r\n\r\n![a code snippet of AnyMemo releated to the data race](https://static.oschina.net/uploads/img/201605/04145607_bXVh.png \"A code segment of AnyMemo\")\r\n\r\nFig.3 a code snippet of AnyMemo releated to the data race\r\n\r\nThe result of analyzer shows that the run method and the `onDestroy()` callback of the activity have races as when the background is finish after `onDestroy()` is executed. From the code we know that this bug is result from the execution of `mDialog.dismiss()` and the system will throw an exception: “java.lang.IllegalArgumentException: View not attached to window manager” because this method is trying to remove the ProgressDialog view which is no longer attached to the window manager.\r\n\r\nAs our test case generation tool is still developing, in order to confirm this potential data race, we first generate a test case manually that will trigger these two callbacks. The figure below shows the corresponding test case. This test case first turns to the download activity (`DownloaderAnyMemo`) and starts the download background thread immediately , waits until the download is end and rotate the screen (this will call `onDestroy()`) and at last check if it runs as expected. In the base schedule, the run method in the finish message will run before `onDestory()`.\r\n\r\n![the test case of AnyMemo](https://static.oschina.net/uploads/img/201605/04151445_XE9U.png \"the test case of AnyMemo\")\r\n\r\nFig.4 the test case of AnyMemo\r\n\r\nAs `onDestroy()` and `run()` are both invoked by the framework asynchronously, RacerDroid will replay the generated test case by reordering the two events with the sequence that `onDestory()` runs before `onPostExecute()`. In this schedule, the exception will be thrown, making the app crash.\r\n\r\n### OI File Manager\r\n[OI File Manager](https://github.com/openintents/filemanager) for Android is an open file manager that seamlessly cooperates with other applications. We use version 2.0.7 to perform our test.\r\n\r\nThe bug of this app is almost same as the one in AnyMemo, they are both corresponding to the `ProgressDialog`. Therefore, we just present the test case of the app instead of describing the detail of this bug. \r\n\r\n### ConnectBot\r\n\r\n[ConnectBot](https://github.com/connectbot/connectbot) is an SSH client for android. We test this application based on a patch of the source code committed by [Asynchronizer](http://mir.cs.illinois.edu/~yulin2/asynchronizer/).\r\n\r\nThe table shows potential data races in 4 components of ConnectBot. We use the one in the `HostListActivity` as an example. This data race is reported by the same work as the code is committed. The code snippet related to the bug is shown in the following figure.\r\n\r\n![the code segment related to the data race](https://static.oschina.net/uploads/img/201605/04170121_dBJP.png \"the code segment related to the data race\")\r\n\r\nFig.5 the code segment related to the data race\r\n\r\nOne can acknowledge that there is a potential data race between the `doInBackground` function which call `saveHost` on `hostdb` and the `onStop` function which set `hostdb` to null. Apparently, if the `onStop` call is before the `FindSaveHostTask`’s execution on `hostdb`, the data race is triggered and a `NullPointerException` would be thrown. This scenario can be produced when the `doInBackground` costs so many time that `onStop` is finish before “`hostdb.saveHost` is called. \r\n\r\nHowever, if we replay the trace directly, the execution of `hostdb.saveHost` and `onStop` function couldn’t be ensured to be in the same order at each replaying because the scheduling of the `FindSaveHostTask` (starts when the instruction `mDevice.pressKeyCode(KeyEvent.KEYCODE_ENTER);` is called) is not predictable. To guarantee the data race can always be triggered, we should exchange the execution order of the two functions.\r\n\r\nThrough our instrumentation, we have inserted the semaphore at the `doInBackground` function. To exchange the order, we need to delay the `AsyncTask` until `onStop` is executed. The test case is shown in this figure.\r\n\r\n![the test case of connectbot](https://static.oschina.net/uploads/img/201605/04171217_Ogtm.png \"the test case of connectbot\")\r\n\r\nFig.6 the test case of connectbot",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}